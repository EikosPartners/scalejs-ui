{"version":3,"sources":["../../src/adapter/adapterViewModel.js"],"names":[],"mappings":"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","file":"adapterViewModel.js","sourcesContent":["/*global define,ko,sandbox,dataservice */\r\nimport sandbox from 'scalejs.sandbox';\r\nimport ko from 'knockout';\r\nimport dataservice from 'dataservice';\r\nimport { observable, observableArray, computed } from 'scalejs.mvvm';\r\nimport { receive, notify } from 'scalejs.messagebus';\r\nimport { createViewModels } from 'scalejs.metadataFactory';\r\n\r\n    /* TODO:\r\n    In PJSON, we used readonly, errors, etc. We need a way to do that outside of adapter\r\n    i.e. plugin to adapter context with other components\r\n    */\r\n\r\n    /** Adapter: a viewless component which keeps track of child nodes and the data for the nodes\r\n     * @module adapter\r\n     *\r\n     * @param {object} node\r\n     *  The configuration object for the module\r\n     * @param {string} node.type='adapter'\r\n     *  The type of the node is adapter\r\n     * @param {string} node.id\r\n     *  The id for the module\r\n     * @param {boolean} [node.lazy=false]\r\n     *  If the child nodes need to be lazily loaded (e.g. delay creation of children viewmodels until data returns)\r\n     * @param {object|Object[]} [node.dataSourceEndpoint]\r\n     *  An object defining the endpoint(s) that makes the ajax calls\r\n     * @param {string} node.dataSourceEndpoint.uri\r\n     *   The uri for the endpoint\r\n     * @param {string} [node.dataSourceEndpoint.url]\r\n     *  The url for the endpoint\r\n     * @param {object} [node.dataSourceEndpoint.keyMap]\r\n     *  A mapper object to map keys\r\n     * @param {string} [node.dataSourceEndpoint.keyMap.resultsKey]\r\n     *  Map the results from the ajax call with this key\r\n     * @param {string} [node.dataSourceEndpoint.keyMap.dataKey]\r\n     *  Extend the data object with this key\r\n     * @param {object} [node.dataSourceEndpoint.options]\r\n     *  Options for the ajax call\r\n     * @param {array} node.children\r\n     *  The json configuration for children nodes which will be mapped to view models and kept track of from the adapter\r\n     * @param {array} [node.plugins]\r\n     *  The json configuration for plugins which will be accessible from getValue function, based upon type\r\n     *\r\n     * @property {array} mappedChildNodes the mapped children nodes\r\n     * @property {observable} data the data retrieved from dataSourceEndpoint and tracked from children\r\n     * @property {object} contextPlugins an object that contains the plugins which have been added to the adapter context\r\n     * @property {context} the context for the adapter (which can be utilized in a custom template)\r\n     * @property {function} dispose the dispose function for all internal subs\r\n     *\r\n     * @example\r\n     * {\r\n     *      \"type\": \"adapter\",\r\n     *      \"id\": \"ADAPTER_ID\",\r\n     *      \"dataSourceEndpoint\": [\r\n     *          {\r\n     *              \"uri\": \"endpoint/uri\",\r\n     *              \"options\": {\r\n     *                  \"type\": \"PUT\"\r\n     *              },\r\n     *              \"keyMap\": {\r\n     *                  \"dataKey\": \"a\",\r\n     *                  \"resultsKey\": \"b\"\r\n     *              }\r\n     *          }\r\n     *      ],\r\n     *      \"children\": [\r\n     *          // children json configuration goes here\r\n     *      ]\r\n     * }\r\n     */\r\n    export default function adapterViewModel(node) {\r\n        let // imports\r\n            unwrap = ko.unwrap,\r\n            merge = sandbox.object.merge,\r\n            get = sandbox.object.get,\r\n            extend = sandbox.object.extend,\r\n            // props\r\n            dictionary = observable({}), // dictionary of nodes with an id\r\n            data = observable({}), // data of dictionary contents\r\n            context = {\r\n                metadata: node.children,\r\n                parentContext: this,\r\n                getValue: getValue,\r\n                dictionary: dictionary,\r\n                data: data\r\n            },\r\n            mappedChildNodes = observableArray(),\r\n            updated = false,\r\n            subs = [],\r\n            dataSyncSubscription,\r\n            plugins = node.plugins ? createViewModels.call(context, node.plugins) : [],\r\n            contextPlugins = {};\r\n\r\n        plugins.forEach(plugin => {\r\n            contextPlugins[plugin.type] = plugin;\r\n        });\r\n\r\n        // recursive function which parses through nodes and adds nodes with an id to dictionary\r\n        function createDictionary(nodes) {\r\n            let dict = dictionary.peek();\r\n            nodes.forEach(node => {\r\n                // add node to dictionary if it isnt there yet\r\n                if (node.id && !dict[node.id]) {\r\n                    dict[node.id] = node;\r\n                    updated = true;\r\n                }\r\n                // add children to dictionary if getValue function is not exposed\r\n                if (!node.getValue) {\r\n                    createDictionary(unwrap(node.mappedChildNodes) || []);\r\n                }\r\n            });\r\n        }\r\n\r\n        // keep the data current if the node value changed with dataSyncDescription\r\n        function syncDataDictionary() {\r\n            dataSyncSubscription = computed(() => {\r\n                let dict = dictionary();\r\n                Object.keys(dict).forEach(id => {\r\n                    if (dict[id].getValue) {\r\n                        data()[id] = dict[id].getValue();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        // pause dataSyncDescription and update the data\r\n        function updateData(newData) {\r\n            dataSyncSubscription && dataSyncSubscription.dispose();\r\n            data(newData);\r\n            syncDataDictionary();\r\n        }\r\n\r\n        // fetches the data from dataSourceEndpoint(s)\r\n        function fetchData() {\r\n            let dataSourceEndpointArray = Array.isArray(node.dataSourceEndpoint)\r\n                ? node.dataSourceEndpoint : [node.dataSourceEndpoint],\r\n                count = 0,\r\n                dataObject = data();\r\n\r\n            dataSourceEndpointArray.forEach(function(endpoint) {\r\n                dataservice.ajax(endpoint, function(error, results) {\r\n                    let resultsByKey,\r\n                        keyMap = endpoint.keyMap || {},\r\n                        newDataObject = {};\r\n\r\n                    count++;\r\n\r\n                    if (!error) {\r\n                        resultsByKey = keyMap.resultsKey ? get(results, keyMap.resultsKey) : results;\r\n                        // optional: keyMap.dataKey path to extend dataObject on\r\n                        if (keyMap.dataKey) {\r\n                            newDataObject[keyMap.dataKey] = resultsByKey;\r\n                        } else {\r\n                            newDataObject = resultsByKey;\r\n                        }\r\n                        extend(dataObject, newDataObject);\r\n                    }\r\n\r\n                    if (count === dataSourceEndpointArray.length) {\r\n                        updateData(dataObject);\r\n                        if (!mappedChildNodes().length) {\r\n                            mappedChildNodes(createViewModels.call(context, node.children || []));\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        function getValue(id) {\r\n            let node = dictionary()[id],\r\n                dataValue = (data() || {})[id];\r\n\r\n            // the node has been defined so get the value from the node\r\n            if (node && node.getValue) { return node.getValue(); }\r\n\r\n            // data has been defined for the node but the node doesnt exist yet\r\n            if (dataValue) { return dataValue; }\r\n\r\n            if (contextPlugins && contextPlugins[id]) {\r\n               return contextPlugins[id]();\r\n            }\r\n            return context.parentContext.getValue(id);\r\n        }\r\n\r\n        if (!node.lazy) {\r\n            mappedChildNodes(createViewModels.call(context, node.children || []));\r\n        }\r\n\r\n        // update dictionary if mappedChildNodes of a node updates\r\n        computed(() => {\r\n            updated = false;\r\n            createDictionary(mappedChildNodes())\r\n            if (updated) {\r\n                dictionary.valueHasMutated();\r\n            }\r\n        });\r\n\r\n        // initialize the data subscription\r\n        syncDataDictionary();\r\n\r\n        // get initial data\r\n        if (node.dataSourceEndpoint) {\r\n            fetchData();\r\n        }\r\n\r\n        // listen for 'refresh' event\r\n        subs.push(receive(node.id + '.refresh', function (options) {\r\n            fetchData(options);\r\n        }));\r\n\r\n    return merge(node, {\r\n        mappedChildNodes: mappedChildNodes,\r\n        data: data,\r\n        contextPlugins: contextPlugins,\r\n        context: context,\r\n        dispose: function () {\r\n            subs.forEach(function (sub) {\r\n                sub.dispose();\r\n            });\r\n        }\r\n    });\r\n};\r\n"]}